Программирование платы
======================

Программирование модуля датчик температуры и влажности
------------------------------------------------------

Как работает датчик температуры и влажности DHT11
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Датчик DHT11 - это цифровой датчик влажности и температуры, который используется для измерения и мониторинга этих параметров в окружающей среде.

+--------------------------------+----------------------------------------------------+
|                                |                                                    |  
|                                | .. figure:: images/11.png                          |
|                                |        :width: 60%                                 |
|                                |        :align: center                              |
|                                |        :alt: датчик температуры и влажности почвы  |
|                                |                                                    | 
|                                |                                                    |        
+--------------------------------+----------------------------------------------------|
| Рабочее напряжение	           | DHT11                                              |
+--------------------------------+----------------------------------------------------+                               
| Максимальный рабочий ток	     | 2,5 мА макс	                                      |
+--------------------------------+----------------------------------------------------+                                              
| Диапазон измерения влажности   | 20-80% / 5%	                                      |
+--------------------------------+----------------------------------------------------+                                                
| Диапазон измерения температуры | 0-50°C / ± 2°C	                                    |
+--------------------------------+----------------------------------------------------+                                                    
| Частота выборки	               | 1 Гц (чтение каждую секунду)	                      |
+--------------------------------+----------------------------------------------------+                                                    
| Размер корпуса	               | 15,5 мм х 12 мм х 5,5 мм	                          |
+--------------------------------+----------------------------------------------------+

Процесс передачи данных от датчика DHT11 к Arduino

Вначале плата Arduino подает на датчик DHT11 сигнал перепада с высокого уровня на низкий с задержкой 18 мкс чтобы запустить датчик DHT11 в работу. Затем Arduino pull-up (подтягивает ее к Vcc как показано на рисунке) линию передачи данных ждет 20-40 мкс ответа от датчика DHT11. Как только датчик DHT11 обнаруживает сигнал, запускающий его в работу (сигнал старта), он передает ответ в виде сигнала низкого уровня длительностью около 80 мкс. А затем контроллер DHT датчика pull up линию передачи данных и удерживает ее в этом состоянии около 80 мкс пока DHT модуль готовится к передаче данных.

.. figure:: images/12.png
       :width: 60%
       :align: center
       :alt: датчик температуры и влажности почвы


Как только на линии передачи данных появилось напряжение низкого уровня это значит что датчик DHT11 передает ответный сигнал на Arduino. Как только этот процесс будет завершен, DHT снова "подтягивает" (pull-up) линию передачи данных на 80 мкс чтобы подготовиться к передаче данных.

Формат данных, передаваемых с DHT на Arduino, для каждого бита начинается с 50 мкс напряжения низкого уровня, а продолжительность напряжения высокого уровня после этого зависит от того какой бит передается - “0” или “1”.

Подключение модуля
~~~~~~~~~~~~~~~~~~  

Подключение модуля к ``Arduino Mega2560`` выполняется в соответствии с распиновкой разъёма. Таким образом, ``линию модуля 5В`` подключим к линии 5В Mega2560, лини. GND - к GND Mega2560, а ``линию управления SIG`` - к цифровой линии 5. В результате, внешний вид подключённого модуля будет выглядеть, как на рисунке:

.. figure:: images/1.png
       :width: 60%
       :align: center
       :alt: датчик температуры и влажности почвы

Программирование
~~~~~~~~~~~~~~~~

Поскольку данный модуль имеет униикальный протокол обмена данными, подобный 1-Wire, для работы с ним рекомендуется использовать подходящую библиотеку. Таких библиотек существует достаточно много, но в данном примере воспользуемся библиотекой “iarduino_DHT”::

    #include <iarduino_DHT.h> // Подключаем библиотеку для работы с датчиком DHT
    iarduino_DHT sensor(5);   // Объявляем объект, указывая номер вывода, к которому подключён модуль
    void setup(){
    Serial.begin(9600);     // Инициируем передачу данных в монитор последовательного порта, на скорости 9600 бод
        delay(1000);            // Приостанавливаем выполнение скетча на 1 секунду, для перехода датчика в активное состояние
    }
    void loop(){                 Serial.print  ("CEHCOP B KOMHATE: ");
    switch(sensor.read()){  // Читаем показания датчика
        case DHT_OK:             Serial.println((String) sensor.hum + "% - " + sensor.tem + "*C"); break;
        case DHT_ERROR_CHECKSUM: Serial.println("HE PABEHCTBO KC");                                break;
        case DHT_ERROR_DATA:     Serial.println("OTBET HE COOTBETCTB. CEHCOPAM 'DHT'");            break;
        case DHT_ERROR_NO_REPLY: Serial.println("HET OTBETA");                                     break;
        default:                 Serial.println("ERROR");                                          break;
    } delay(8000);          // Приостанавливаем выполнение скетча на 8 секунд, между выводами показаний
    }

В результате, загрузив данный код в контроллер стандартным способом и открыв монитор порта, можно увидеть следующие данные:

.. figure:: images/2.png
       :width: 100%
       :align: center
       :alt: сериал порт


Программирование модуля датчик влажности почвы
----------------------------------------------

Подключение
~~~~~~~~~~~

Используя провода ``«Папа — Мама»``, подключаем  напрямую к контроллеру ``ESP-JSAR``.

Датчик влажности почвы является аналоговым датчиком и подключается через блок аналоговых устройств на плате расширения. На экран можно выводить показания считываемые датчиком. На рисунке 30 показано подключение в живую.

.. |pic1| image:: images/3.png
   :width: 50%

.. |pic2| image:: images/4.png
   :width: 43%

|pic1| |pic2|

Программирование
~~~~~~~~~~~~~~~~

::

  #include <JsAr.h>               // Подключение библиотеки для работы с платой ESP.

  void setup() {
    JsAr.begin();                 // Начинаем работу с платой ESP. Без этой строчки ничего работать не будет!
    pinMode(A0, INPUT);           // Устанавливаем пин A0 как вход.
    Serial.begin(115200);         // Начинаем общение по сериал-порту.
  }

  void loop() {
    int tempData = analogRead(A0);                  // Считываем аналоговый сигнал.
    int intData = map(tempData, 0, 2048, 0, 100);   // Преобразовываем сигнал из некоторых условных единиц в проценты.
    String stringData = String(intData);            // Преобразовываем данные в строку.
    Serial.println(stringData);                     // Выводим в сериал-порт.
    delay(100);
  }

Программирование помпы
----------------------

Подключение
~~~~~~~~~~~

Насос подключается точно так же как и вентиляторы для системы вентиляции, отличия только в программном коде. Так же насос может взаимодействовать с датчиком влажности почвы и с датчиком уровня воды. К примеру когда влажность почвы недостаточна, включается насос и насыщает почву водой. Или насос будет наполнять емкость водой, пока датчик уровня воды не тонет.

.. figure:: images/5.png
       :width: 60%
       :align: center
       :alt: Помпа


Программирование
~~~~~~~~~~~~~~~~

::

  #include <JsAr.h>	// Подключение библиотеки для работы с платой ESP. #include <DxlMaster.h>		// Подключение библиотеки для работы с DXL-устройствами.
  DynamixelDevice pump(0x0D);

  void setup() {
    JsAr.begin();	// Начинаем работу с платой ESP. Без этой строчки ничего работать не будет!
    DxlMaster.begin(57600);	// Начинаем работу с DXL-устройствами.
    pump.init();	// Инициализируем кнопку и силовой ключ. 
  } 

  void loop() {
    pump.write(28, 255);	// Непосредственное открытие ключа записью значения 255 в нужный регистр.
  }

Программирование датчика уровня воды
------------------------------------

Подключение
~~~~~~~~~~~

Схема подключения поплавка изображена на фото.

.. figure:: images/6.png
       :width: 60%
       :align: center
       :alt: Поплавок


Программирование
~~~~~~~~~~~~~~~~

::

  #include <JsAr.h>	// Подключение библиотеки для работы с платой ESP.
  #define floatSensor 4	// Объявление пина, к которому подключен поплавок.

  void setup() {
    JsAr.begin();	// Начало работы с платой ESP.
    pinMode(floatSensor, INPUT_PULLUP);	// Настраиваем пин поплавка как вход.
    Serial.begin(115200);	// Начало общения по сериал порту.
  }

  void loop() {
    if (!digitalRead(floatSensor)) {	// Считываем данные с пина. Если на пине логический 0, то цепь разомкнута,
      Serial.println("CEHCOP TOHET");	// а значит, сенсор тонет.
    }
  }

Программирование светодиодной ленты
-----------------------------------

Подключение светодиодной ленты
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Подключение происходит также как и с остальными модулями,  подключаемыми в ``силовой ключ DXL``: красный провод к 5V, черный к GND.

Программирование
~~~~~~~~~~~~~~~~

::

  #include <JsAr.h>	// Подключение библиотеки для работы с платой ESP. #include <DxlMaster.h>		// Подключение библиотеки для работы с DXL-устройствами.
  DynamixelDevice ledstrip(0x0C);

  void setup() {
    JsAr.begin();	// Начинаем работу с платой ESP. Без этой строчки ничего работать не будет!
    DxlMaster.begin(57600);	// Начинаем работу с DXL-устройствами.
    ledstrip.init();	// Инициализируем кнопку и силовой ключ. 
  } 

  void loop() {
    ledstrip.write(28, 255);	// Непосредственное открытие ключа записью значения 255 в нужный регистр.
  }

Программирование RGB ленты
--------------------------

Подключение
~~~~~~~~~~~

Подключение RGB-ленты к модулю силовых ключей происходит не так как обычная светодиодная лента. У RGB-ленты три цветовых канала “Красный”, “Зеленый”, “Синий”, следовательно подключение должно быть по трем разным каналам.

.. |pic3| image:: images/7.png
   :width: 20%

.. |pic4| image:: images/8.png
   :width: 60%

|pic3| |pic4|


Программирование RGB-ленты
~~~~~~~~~~~~~~~~~~~~~~~~~~

::

  #include <JsAr.h>	// Подключение библиотеки для работы с платой ESP. 
  #include <iarduino_I2C_Relay.h>	// Подключение библиотеки для работы с I2C силовым ключом.

  iarduino_I2C_Relay fets1(0x09);	// Создаем объект для работы с силовым ключом.
  void setup() {
    JsAr.begin();	// Начинаем работу с платой ESP.
    fets1.begin();	// Инициализируем силовой ключ.
    Serial.begin(115200);
  }

  void loop() {
    if (Serial.available()) {	// В случае, если в буфере что-то есть, то заходим в условие.
      char a = Serial.read();	// Считываем один символ из буфера.
      switch(a) { // Здесь массив вариантов включения и выключения необходимых цветов в зависимости от символа.
        case '1': fets1.digitalWrite(1, HIGH); 
          break;
        case 'q': fets1.digitalWrite(1, LOW); 
          break; 
        case '2': fets1.digitalWrite(2, HIGH); 
          break; 
        case 'w': fets1.digitalWrite(2, LOW); 
          break; 
        case '3': fets1.digitalWrite(3, HIGH); 
          break; 
        case 'e': fets1.digitalWrite(3, LOW); 
          break; 
        default:
          fets1.digitalWrite(1, LOW); // Если пришел символ, который мы не ожидаем, выключаем все.
          fets1.digitalWrite(2, LOW); 
          fets1.digitalWrite(3, LOW); 
          break;
      } 
    }
  }

Программирование дисплея Agrolab GH
--------------------------------

Подключение дисплея
~~~~~~~~~~~~~~~~~~~

Сам дисплей подключается через интерфейс I2C к плате расширения в блоки.

.. figure:: images/9.png
       :width: 60%
       :align: center
       :alt: Дисплей


После подачи питания на дисплей и включения дисплея, необходимо настроить контрастность при помощи отвертки поворачивая потенциометр(Рисунок 17) до четкого изображения на дисплее.

.. figure:: images/10.png
       :width: 60%
       :align: center
       :alt: Дисплей


После настройки контрастности дисплея, мы увидим выходные данные. Дисплей готов к дальнейшей работе. При помощи программного кода можно выводить на дисплей любые параметры которые необходимы.

Программирование
~~~~~~~~~~~~~~~~

Простой пример проверки работоспособности диплея::

  #include <JsAr.h>	// Подключение библиотеки для работы с платой ESP. 
  #include <Wire.h>		// Подключение библиотеки для работы с I2C устройствами.
  #include <LiquidCrystal_I2C.h>	// Подключение библиотеки для работы с LCD-дисплеем.


  /* Создаем экземпляр класса LiquidCrystal_I2C,
  называем его lcd. Первый аргумент - адрес I2C-устройства,
  второй - количество символов в строке, третий -
  количество строк, поддерживаемое данным дисплеем.
  */
  LiquidCrystal_I2C lcd(0x27, 16, 4);

  unsigned long timerLCD = 0;	// Создаем таймер для обновления данных дисплея.

  void setup() {
    JsAr.begin();	// Начинаем работу с платой ESP. Без этой строчки ничего работать не будет!
    lcd.init();	// Инициализируем дисплей. 
    lcd.backlight();		// Включаем подсветку
    timerLCD = millis();	// Приравниваем таймер к текущему времени.
  }

  void loop() {
  /* Если разница между текущим временем и значением таймера
  отличается больше, чем на 1000 миллисекунд (1 секунда),
  то заходим внутрь условия (т.е. условие будет выполняться
  раз в секунду, не препятствуя выполнению остального кода.
  */
    if (millis() - timerLCD > 1000) {
      timerLCD = millis();	                // Присваиваем таймеру текущее время (последнего срабатывания).
      lcd.clear();	                        // Очищаем дисплей от данных.
      lcd.setCursor(0, 0);	                // Ставим курсор на позицию (символ, строка). 
      lcd.print("Applied Robotics");	    	// Выводим надпись Applied Robotics. 
      lcd.setCursor(0, 1);	                // Переносим курсор на новую строку. 
      lcd.print(timerLCD / 1000);		        // Выводим время в секундах.
    }
  }

Написание интерфейса на дисплее и управление с кнопок
-----------------------------------------------------

Подключение
~~~~~~~~~~~

Подключение дисплея продемонстрировано в предыдущем пункте. 

Кнопки соединяются последовательно по протоколу DXL. У каждой имеется свой айди, который можно определить через библиотеку ``DynamixelDevice`` со встроенным примером ``Console``.

Программирование интерфейса
~~~~~~~~~~~~~~~~~~~~~~~~~~~

  :: 
    
    #include <JsAr.h>   // Подключение библиотеки для работы с платой ESP.
    #include <DxlMaster2.h>       // Подключение библиотеки для работы с DXL-устройствами.
    #include <Wire.h>                     // Подключение библиотеки для работы с I2C устройствами.
    #include <LiquidCrystal_I2C.h>        // Подключение библиотеки для работы с LCD-дисплеем.

    #define NUM_BTNS 5

    uint8_t ids[NUM_BTNS] = {0x01,0x02,0x03,0x04,0x05};
    DynamixelDevice* btnDxl = (DynamixelDevice*)malloc(sizeof(DynamixelDevice) * NUM_BTNS);

    LiquidCrystal_I2C lcd(0x27, 16, 4);

    int init_buttons()
    {
      for(int i=0;i<NUM_BTNS;i++)
      {
        btnDxl[i] = DynamixelDevice(ids[i]);
        btnDxl[i].init();
        if (btnDxl[i].ping() != DYN_STATUS_OK)
          return ids[i];
      }
      return -1;
      
    }

    int read_buttons()
    {
      uint8_t btn;                                       // Переменные, необходимые для работы с кнопкой.

      for(int i=0;i<NUM_BTNS;i++)
      {
        btnDxl[i].read((uint8_t)27, (uint8_t)1, &btn); // Считывание регистра "нажатия" с кнопки.
        if (btn == 1)
        {
          delay(10);
          btnDxl[i].read((uint8_t)27, (uint8_t)1, &btn); // Считывание регистра "нажатия" с кнопки.
          if (btn ==1)
            return i;
        }
      }
      return -1;
    }

    int init_lcd()
    {
      byte count = 0;
      
      Wire.begin();
      for (byte i = 1; i < 120; i++)
      {
        Wire.beginTransmission (i);
        if (Wire.endTransmission () == 0)
          {
            if(i == 0x27)
            {
              count++;
              Serial.println("DISPLAY FOUND!");
              break;
            }
          delay (1);  
          } 
      } 

      if (count == 0)
        return 1;
        
      lcd.init();                                           // Инициализируем дисплей.
      lcd.backlight();                                      // Включаем подсветку
      lcd.setCursor(4.5, 1);                                // Устанавливаем курсор в середину 2 строки
      lcd.print("AGROLAB");                                 // Выводим текст
      delay(500);
      lcd.clear();  
      return -1;
    }


    typedef void(*Action)(); 

    class menu{
      private:
        String * menu_items;
        int selected_item;
        uint8_t num_items;
        Action   *actions;
        bool active; 
      public:
        menu(uint8_t n, String * items)
        {
          num_items = n - 1;
          menu_items = new String[n];
          actions = new Action[n];
          selected_item = 0;
          for(int i = 0; i<n;i++)
          {
            menu_items[i] = items[i];
            actions[i] = NULL;
          }
          active = false;
        }
        
        void bind_action(uint8_t n, Action act)
        {
          actions[n] = act;
        }
        
        void menu_down()
        {
          selected_item++;
          if (selected_item> num_items)
            selected_item = 0;
        }
        
        void menu_up()
        {
          selected_item--;
          if (selected_item < 0 )
            selected_item = num_items;
        }
        
        void menu_push()
        {
          if(actions[selected_item] == NULL)
            Serial.println("ACTION IS NOT BINDED TO THIS MENU ITEM");
          else
            actions[selected_item]();  
        }
        
        void draw_menu()
        { 
          if (active)
          { 
            lcd.clear();
            lcd.setCursor(0, selected_item % 4);
            lcd.print(char(126));                          
            int page_end = (selected_item / 4)*4 + 4 > num_items ? num_items % 4+1: 4;
            for(int i = 0; i<page_end; i++)  
            {                       
            lcd.setCursor(1, i);
            lcd.print(menu_items[(selected_item / 4)*4+i]);
            }
          }        
        }

        void set_active()
        {
          active = true;
        }
        
        void unset_active()
        {
          active = false;
        }
        
        bool get_active()
        {
          return active;
        }
    };

    #define MENU_MAIN_ITEMS 3
    String main_items[MENU_MAIN_ITEMS] = { "Controls", "Settings", "Calibration" };
    menu menu_main(MENU_MAIN_ITEMS, main_items);

    #define MENU_SUB_CONTROLS 5
    String controls_items[MENU_SUB_CONTROLS] = { "Web Set", "Airing Set", "LED Set", "Watering", "Back" };
    menu menu_controls(MENU_SUB_CONTROLS, controls_items);

    #define MENU_SUB_AIRING 4
    String airing_items[MENU_SUB_AIRING] = { "Time", "Humidity", "Button", "Back" };
    menu menu_airing(MENU_SUB_AIRING, airing_items);

    void enter_controls() {
      menu_main.unset_active();
      menu_controls.set_active();
    }
    void enter_settings() {
      Serial.println("Settings unavailable");
    }
    void enter_calibration() {
      Serial.println("Calibration unavailable");
    }
    void enter_airing() {
      menu_controls.unset_active();
      menu_airing.set_active();
    }

    void enter_web() {
      Serial.println("Web settings unavailable");
    }
    void enter_led() {
      Serial.println("LED settings unavailable");
    }
    void enter_watering() {
      Serial.println("Watering settings unavailable");
    }
    void back_main() {
      menu_main.set_active();
      menu_controls.unset_active();
    }

    void airing_time() {
      Serial.println("Airing is set to on time");
    }
    void airing_hum() {
      Serial.println("Airing is set to on humidity");
    }
    void airing_but() {
      Serial.println("Airing is set to on button");
    }
    void airing_back() {
      menu_controls.set_active();
      menu_airing.unset_active();
    }


    void setup() {
      JsAr.begin();            // Начинаем работу с платой ESP. Без этой строчки ничего работать не будет!
      DxlMaster.begin(57600);  // Начинаем работу с DXL-устройствами.
      Serial.begin(115200);

      Serial.println(String("ONBOARD VOLTAGE:") + JsAr.readVoltage());

      int status = init_buttons();
      if (status != -1) {
        Serial.println("BTN WITH ID " + String(ids[status]) + " NOT INITIALISED! Aborting.");
        ESP.restart();
      }

      status = init_lcd();
      if (status != -1) {
        Serial.println("LCD NOT INITIALISED! Aborting.");
        ESP.restart();
      }

      menu_main.bind_action(0, enter_controls);
      menu_main.bind_action(1, enter_settings);
      menu_main.bind_action(2, enter_calibration);
      menu_main.set_active();

      menu_controls.bind_action(0, enter_web);
      menu_controls.bind_action(1, enter_airing);
      menu_controls.bind_action(2, enter_led);
      menu_controls.bind_action(3, enter_watering);
      menu_controls.bind_action(4, back_main);

      menu_airing.bind_action(0, airing_time);
      menu_airing.bind_action(1, airing_hum);
      menu_airing.bind_action(2, airing_but);
      menu_airing.bind_action(3, airing_back);
    }

    void loop() {
      delay(100);
        Serial.println(menu_main.get_active());
          Serial.println(menu_controls.get_active());
            Serial.println(menu_airing.get_active());
            Serial.println("---------------------------");
      menu_main.draw_menu();
      menu_controls.draw_menu();
      menu_airing.draw_menu();
      
      switch (read_buttons()) {
        case 0:
          if(menu_main.get_active())
          {
            menu_main.menu_down();
          }else
          if(menu_controls.get_active())
          {
            menu_controls.menu_down();
          }else
          if(menu_airing.get_active())
          {
            menu_airing.menu_down();
          }
          break;
        case 1:
          if(menu_main.get_active())
          {
            menu_main.menu_up();
          }else
          if(menu_controls.get_active())
          {
            menu_controls.menu_up();
          }else
          if(menu_airing.get_active())
          {
            menu_airing.menu_up();
          }
          break;
        case 2:
          if(menu_main.get_active())
          {
            menu_main.menu_push();
          }
          else
          if(menu_controls.get_active())
          {
            menu_controls.menu_push();
          }else
          if(menu_airing.get_active())
          {
            menu_airing.menu_push();
          }
          break;
      }
    } 
