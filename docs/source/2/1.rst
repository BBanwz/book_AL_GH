Программирование платы
======================

Программирование модуля датчик температуры и влажности
------------------------------------------------------

Подключение модуля
~~~~~~~~~~~~~~~~~~  
Подключение модуля к ``Arduino Mega2560`` выполняется в соответствии с распиновкой разъёма. Таким образом, ``линию модуля 5В`` подключим к линии 5В Mega2560, лини. GND - к GND Mega2560, а ``линию управления SIG`` - к цифровой линии 5. В результате, внешний вид подключённого модуля будет выглядеть, как на рисунке:

.. figure:: images/1.png
       :width: 60%
       :align: center
       :alt: датчик температуры и влажности почвы

Программирование
~~~~~~~~~~~~~~~~

Поскольку данный модуль имеет униикальный протокол обмена данными, подобный 1-Wire, для работы с ним рекомендуется использовать подходящую библиотеку. Таких библиотек существует достаточно много, но в данном примере воспользуемся библиотекой “iarduino_DHT”::

    #include <iarduino_DHT.h> // Подключаем библиотеку для работы с датчиком DHT
    iarduino_DHT sensor(5);   // Объявляем объект, указывая номер вывода, к которому подключён модуль
    void setup(){
    Serial.begin(9600);     // Инициируем передачу данных в монитор последовательного порта, на скорости 9600 бод
        delay(1000);            // Приостанавливаем выполнение скетча на 1 секунду, для перехода датчика в активное состояние
    }
    void loop(){                 Serial.print  ("CEHCOP B KOMHATE: ");
    switch(sensor.read()){  // Читаем показания датчика
        case DHT_OK:             Serial.println((String) sensor.hum + "% - " + sensor.tem + "*C"); break;
        case DHT_ERROR_CHECKSUM: Serial.println("HE PABEHCTBO KC");                                break;
        case DHT_ERROR_DATA:     Serial.println("OTBET HE COOTBETCTB. CEHCOPAM 'DHT'");            break;
        case DHT_ERROR_NO_REPLY: Serial.println("HET OTBETA");                                     break;
        default:                 Serial.println("ERROR");                                          break;
    } delay(8000);          // Приостанавливаем выполнение скетча на 8 секунд, между выводами показаний
    }

В результате, загрузив данный код в контроллер стандартным способом и открыв монитор порта, можно увидеть следующие данные:

.. figure:: images/2.png
       :width: 100%
       :align: center
       :alt: сериал порт


Программирование модуля датчик влажности почвы
----------------------------------------------

Подключение
~~~~~~~~~~~

Используя провода ``«Папа — Мама»``, подключаем  напрямую к контроллеру ``ESP-JSAR``.

Датчик влажности почвы является аналоговым датчиком и подключается через блок аналоговых устройств на плате расширения. На экран можно выводить показания считываемые датчиком. На рисунке 30 показано подключение в живую.

.. |pic1| image:: images/3.png
   :width: 50%

.. |pic2| image:: images/4.png
   :width: 43%

|pic1| |pic2|

Программирование
~~~~~~~~~~~~~~~~

::

  #include <JsAr.h>               // Подключение библиотеки для работы с платой ESP.

  void setup() {
    JsAr.begin();                 // Начинаем работу с платой ESP. Без этой строчки ничего работать не будет!
    pinMode(A0, INPUT);           // Устанавливаем пин A0 как вход.
    Serial.begin(115200);         // Начинаем общение по сериал-порту.
  }

  void loop() {
    int tempData = analogRead(A0);                  // Считываем аналоговый сигнал.
    int intData = map(tempData, 0, 2048, 0, 100);   // Преобразовываем сигнал из некоторых условных единиц в проценты.
    String stringData = String(intData);            // Преобразовываем данные в строку.
    Serial.println(stringData);                     // Выводим в сериал-порт.
    delay(100);
  }

Программирование помпы
----------------------

Подключение
~~~~~~~~~~~

Насос подключается точно так же как и вентиляторы для системы вентиляции, отличия только в программном коде. Так же насос может взаимодействовать с датчиком влажности почвы и с датчиком уровня воды. К примеру когда влажность почвы недостаточна, включается насос и насыщает почву водой. Или насос будет наполнять емкость водой, пока датчик уровня воды не тонет.

.. figure:: images/5.png
       :width: 60%
       :align: center
       :alt: Помпа


Программирование
~~~~~~~~~~~~~~~~

::

  #include <JsAr.h>	// Подключение библиотеки для работы с платой ESP. #include <DxlMaster.h>		// Подключение библиотеки для работы с DXL-устройствами.
  DynamixelDevice pump(0x0D);

  void setup() {
    JsAr.begin();	// Начинаем работу с платой ESP. Без этой строчки ничего работать не будет!
    DxlMaster.begin(57600);	// Начинаем работу с DXL-устройствами.
    pump.init();	// Инициализируем кнопку и силовой ключ. 
  } 

  void loop() {
    pump.write(28, 255);	// Непосредственное открытие ключа записью значения 255 в нужный регистр.
  }

Программирование датчика уровня воды
------------------------------------

Подключение
~~~~~~~~~~~

Схема подключения поплавка изображена на фото.

.. figure:: images/6.png
       :width: 60%
       :align: center
       :alt: Поплавок


Программирование
~~~~~~~~~~~~~~~~

::

  #include <JsAr.h>	// Подключение библиотеки для работы с платой ESP.
  #define floatSensor 4	// Объявление пина, к которому подключен поплавок.

  void setup() {
    JsAr.begin();	// Начало работы с платой ESP.
    pinMode(floatSensor, INPUT_PULLUP);	// Настраиваем пин поплавка как вход.
    Serial.begin(115200);	// Начало общения по сериал порту.
  }

  void loop() {
    if (!digitalRead(floatSensor)) {	// Считываем данные с пина. Если на пине логический 0, то цепь разомкнута,
      Serial.println("CEHCOP TOHET");	// а значит, сенсор тонет.
    }
  }

Программирование светодиодной ленты
-----------------------------------

Подключение светодиодной ленты
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Подключение происходит также как и с остальными модулями,  подключаемыми в ``силовой ключ DXL``: красный провод к 5V, черный к GND.

Программирование
~~~~~~~~~~~~~~~~

::

  #include <JsAr.h>	// Подключение библиотеки для работы с платой ESP. #include <DxlMaster.h>		// Подключение библиотеки для работы с DXL-устройствами.
  DynamixelDevice ledstrip(0x0C);

  void setup() {
    JsAr.begin();	// Начинаем работу с платой ESP. Без этой строчки ничего работать не будет!
    DxlMaster.begin(57600);	// Начинаем работу с DXL-устройствами.
    ledstrip.init();	// Инициализируем кнопку и силовой ключ. 
  } 

  void loop() {
    ledstrip.write(28, 255);	// Непосредственное открытие ключа записью значения 255 в нужный регистр.
  }

Программирование RGB ленты
--------------------------

Подключение
~~~~~~~~~~~

Подключение RGB-ленты к модулю силовых ключей происходит не так как обычная светодиодная лента. У RGB-ленты три цветовых канала “Красный”, “Зеленый”, “Синий”, следовательно подключение должно быть по трем разным каналам.

.. |pic3| image:: images/7.png
   :width: 20%

.. |pic4| image:: images/8.png
   :width: 60%

|pic3| |pic4|


Программирование RGB-ленты
~~~~~~~~~~~~~~~~~~~~~~~~~~

::

  #include <JsAr.h>	// Подключение библиотеки для работы с платой ESP. 
  #include <iarduino_I2C_Relay.h>	// Подключение библиотеки для работы с I2C силовым ключом.

  iarduino_I2C_Relay fets1(0x09);	// Создаем объект для работы с силовым ключом.
  void setup() {
    JsAr.begin();	// Начинаем работу с платой ESP.
    fets1.begin();	// Инициализируем силовой ключ.
    Serial.begin(115200);
  }

  void loop() {
    if (Serial.available()) {	// В случае, если в буфере что-то есть, то заходим в условие.
      char a = Serial.read();	// Считываем один символ из буфера.
      switch(a) { // Здесь массив вариантов включения и выключения необходимых цветов в зависимости от символа.
        case '1': fets1.digitalWrite(1, HIGH); 
          break;
        case 'q': fets1.digitalWrite(1, LOW); 
          break; 
        case '2': fets1.digitalWrite(2, HIGH); 
          break; 
        case 'w': fets1.digitalWrite(2, LOW); 
          break; 
        case '3': fets1.digitalWrite(3, HIGH); 
          break; 
        case 'e': fets1.digitalWrite(3, LOW); 
          break; 
        default:
          fets1.digitalWrite(1, LOW); // Если пришел символ, который мы не ожидаем, выключаем все.
          fets1.digitalWrite(2, LOW); 
          fets1.digitalWrite(3, LOW); 
          break;
      } 
    }
  }

Программирование дисплея теплицы
--------------------------------

Подключение дисплея
~~~~~~~~~~~~~~~~~~~

Сам дисплей подключается через интерфейс I2C к плате расширения в блоки.

.. figure:: images/9.png
       :width: 60%
       :align: center
       :alt: Дисплей


После подачи питания на дисплей и включения дисплея, необходимо настроить контрастность при помощи отвертки поворачивая потенциометр(Рисунок 17) до четкого изображения на дисплее.

.. figure:: images/10.png
       :width: 60%
       :align: center
       :alt: Дисплей


После настройки контрастности дисплея, мы увидим выходные данные. Дисплей готов к дальнейшей работе. При помощи программного кода можно выводить на дисплей любые параметры которые необходимы.

Программирование
~~~~~~~~~~~~~~~~

Простой пример проверки работоспособности диплея::

  #include <JsAr.h>	// Подключение библиотеки для работы с платой ESP. 
  #include <Wire.h>		// Подключение библиотеки для работы с I2C устройствами.
  #include <LiquidCrystal_I2C.h>	// Подключение библиотеки для работы с LCD-дисплеем.


  /* Создаем экземпляр класса LiquidCrystal_I2C,
  называем его lcd. Первый аргумент - адрес I2C-устройства,
  второй - количество символов в строке, третий -
  количество строк, поддерживаемое данным дисплеем.
  */
  LiquidCrystal_I2C lcd(0x27, 16, 4);

  unsigned long timerLCD = 0;	// Создаем таймер для обновления данных дисплея.

  void setup() {
    JsAr.begin();	// Начинаем работу с платой ESP. Без этой строчки ничего работать не будет!
    lcd.init();	// Инициализируем дисплей. 
    lcd.backlight();		// Включаем подсветку
    timerLCD = millis();	// Приравниваем таймер к текущему времени.
  }

  void loop() {
  /* Если разница между текущим временем и значением таймера
  отличается больше, чем на 1000 миллисекунд (1 секунда),
  то заходим внутрь условия (т.е. условие будет выполняться
  раз в секунду, не препятствуя выполнению остального кода.
  */
    if (millis() - timerLCD > 1000) {
      timerLCD = millis();	                // Присваиваем таймеру текущее время (последнего срабатывания).
      lcd.clear();	                        // Очищаем дисплей от данных.
      lcd.setCursor(0, 0);	                // Ставим курсор на позицию (символ, строка). 
      lcd.print("Applied Robotics");	    	// Выводим надпись Applied Robotics. 
      lcd.setCursor(0, 1);	                // Переносим курсор на новую строку. 
      lcd.print(timerLCD / 1000);		        // Выводим время в секундах.
    }
  }
